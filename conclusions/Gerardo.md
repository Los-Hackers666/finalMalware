# Conclusiones

Esta práctica final resultó un gran reto, pues requirió adentrarse en documentación específica de Windows del lado del cliente, y Linux del lado del servidor.
Una vez que entendimos el funcionamiento de los sockets y las estructuras que utilizan para recibir construirse, este conocimiento lo aplicamos para implementar
la lógica en la que el servidor y el cliente están en constante comunicación; esto fue lo más complicado. A pesar de haber leído la documentación, la manera en 
que los datos son enviados y recibidos es confusa. Tiene que ver mucho en cómo funciona el protocolo TCP y el envío de sus tramas, además de las implementaciones
particulares para cada sistema operativo. Esto ocasionó que las funciones que manejan los sockets estuvieran en constante cambio para adaptarlas a lo que funcionaba.

Crear un entorno cliente/servidor para dos sistemas operativos distintos también resultó un reto, pues las sintaxis de las funciones, aunque parecidas entre sí,
utilizan distintos tipos de datos y parámetros que pueden o no tener cosas en común; culpo a Windows. De este modo, tuvimos que analizar cada parte del servidor
contra la del cliente para saber que los datos enviados correspondían con los recibidos tanto de un lado como de otro.

En general, cada parte de los programas fue creada por separado pues resultaba mucho más fácil la modularidad. Primero nos dedicamos a lograr que el cifrado
funcionara, y una vez que se completó, pasamos al desarrollo del servidor, después del cliente, y al final se juntaron las partes donde mejor encajaban para 
lograr el comportamiento esperado.
